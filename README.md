Tile-Crawler
An LLM-Powered Text-Based Dungeon Crawler with Custom Font Tilesets
Tile-Crawler is a next-generation roguelike that merges procedural world generation, LLM storytelling, and ASCII/roguelike visual aesthetics. It uses large language models as dynamic dungeon masters that output text-based tile grids, rendered in-browser using custom font tilesets.
üéÆ Overview
Tile-Crawler represents a new approach to procedural game design: instead of hardcoded rules and static content, the game world is generated and narrated by an AI that maintains narrative continuity, remembers your actions, and creates coherent, evolving dungeons as you explore.
Core Concept:
LLM (Game Master)
       ‚Üì
Generates tilemap as text/JSON
       ‚Üì
React Frontend renders using custom font tileset
       ‚Üì
Player input ‚Üí sent back to LLM for next state
The LLM acts as both world generator and storyteller, while the frontend displays tiles using a custom font where each character represents a visual element (walls, floors, player, NPCs, items).
‚ú® Features
Core Gameplay

Dynamic World Generation: Every room, corridor, and encounter is generated by the LLM in real-time
Persistent World Memory: Previously explored areas are saved and remain consistent
Narrative Continuity: The LLM maintains a story log, ensuring tone and context across your adventure
Character Dialogue: Encounter NPCs with dynamic personalities and contextual conversations
Inventory System: Pick up, use, and manage items throughout your journey
Custom Font Tilesets: Render the world using beautiful monospaced tile fonts

Technical Features

Stateful LLM Integration: Context-aware AI that remembers previous rooms, actions, and story beats
Modular Architecture: Clean separation between world state, narrative memory, and inventory
RESTful API: FastAPI backend for clean client-server communication
WebSocket Support: Real-time game updates without polling
Database Persistence: SQLite/PostgreSQL support with repository pattern
User Authentication: JWT-based login system with per-user saves
Real-time Rendering: React-based frontend with Tailwind styling
Extensible Design: Easy to add new tile types, NPC behaviors, or game mechanics

Advanced Systems

GASR Glyph System: Semantic glyph registry with 80+ tile definitions
Procedural Glyph Foundry: AI-powered tile generation pipeline
Multi-Layer Rendering: 6-layer SNES-style compositing system
Edge Compatibility: Wave Function Collapse-ready tile meshing

üèóÔ∏è Architecture
System Flow
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Player Input                      ‚îÇ
‚îÇ            (north, south, east, west,                ‚îÇ
‚îÇ             talk, take, use, etc.)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              FastAPI Backend                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ           LLM Engine (OpenAI)               ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Generates next state                     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Maintains narrative voice                ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Handles NPC dialogue                     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Manages item interactions                ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                   ‚Üì          ‚Üì          ‚Üì            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   World      ‚îÇ ‚îÇ  Narrative   ‚îÇ ‚îÇ Inventory‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   Memory     ‚îÇ ‚îÇ   Memory     ‚îÇ ‚îÇ  State   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ (rooms/map)  ‚îÇ ‚îÇ (story log)  ‚îÇ ‚îÇ (items)  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               React Frontend                         ‚îÇ
‚îÇ  ‚Ä¢ Renders tilemap using custom font                ‚îÇ
‚îÇ  ‚Ä¢ Displays narrative descriptions                   ‚îÇ
‚îÇ  ‚Ä¢ Shows inventory                                   ‚îÇ
‚îÇ  ‚Ä¢ Provides movement/action controls                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Tile System (GASR)
The game uses the **Glyph Addressing & Semantic Registry (GASR)** system - a font-driven, tile-based rendering system where every character cell is a graphical tile with semantic meaning.

**Core Concepts:**
- **Font = Tileset ROM** - Custom fonts contain tile graphics
- **Text Grid = VRAM** - The map is a text buffer
- **Glyph = Tile + State + Meaning** - Each glyph has physics, visuals, audio, narrative

**Unicode PUA Codepoint Bands:**
```
E000-E0FF: Empty/void spaces
E100-E1FF: Ground/floors (stone, dirt, grass, wood)
E200-E2FF: Walls/structures (stone, brick, corners)
E300-E3FF: Doors/windows (wood, iron, locked, secret)
E400-E4FF: Fluids (water, lava, acid, blood)
E500-E5FF: Props/objects (chests, altars, torches)
E600-E6FF: Items (coins, potions, weapons)
E700-E7FF: Entities (player, enemies, NPCs)
E800-E8FF: Effects (fire, poison, traps)
EA00-EAFF: Overlays (lighting, damage, highlights)
```

**Legacy Character Mapping:**
```
Character ‚Üí Visual Tile
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  #      ‚Üí   Wall
  .      ‚Üí   Floor
  @      ‚Üí   Player
  !      ‚Üí   Item
  ‚ò∫      ‚Üí   NPC
  ‚âà      ‚Üí   Water
  ^      ‚Üí   Trap
  +      ‚Üí   Door
```

**6-Layer Rendering (SNES-style):**
```
Layer 0: Background terrain
Layer 1: Structures (walls, doors)
Layer 2: Entities (player, enemies)
Layer 3: Effects/particles
Layer 4: Lighting overlays
Layer 5: UI elements
```
üìÅ Project Structure
tile-crawler/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                  # FastAPI application entry point
‚îÇ   ‚îú‚îÄ‚îÄ llm_engine.py           # OpenAI integration & prompt management
‚îÇ   ‚îú‚îÄ‚îÄ game_engine.py          # Core game logic and state management
‚îÇ   ‚îú‚îÄ‚îÄ world_state.py          # Persistent world/room storage
‚îÇ   ‚îú‚îÄ‚îÄ narrative_memory.py     # Story continuity system
‚îÇ   ‚îú‚îÄ‚îÄ inventory_state.py      # Player inventory management
‚îÇ   ‚îú‚îÄ‚îÄ player_state.py         # Player stats and progression
‚îÇ   ‚îú‚îÄ‚îÄ websocket_manager.py    # Real-time WebSocket connections
‚îÇ   ‚îú‚îÄ‚îÄ auth/                   # User authentication system
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py          # User, Token models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service.py         # JWT & password handling
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py    # FastAPI auth dependencies
‚îÇ   ‚îú‚îÄ‚îÄ database/               # Database persistence layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py          # Pydantic DB models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository.py      # SQLite/PostgreSQL repository
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ converter.py       # State conversion utilities
‚îÇ   ‚îú‚îÄ‚îÄ glyphs/                 # GASR Glyph System
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py          # Glyph, Animation models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ registry.py        # Glyph registry singleton
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layers.py          # Multi-layer rendering
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ legends.py         # LLM context compression
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ engine.py          # Glyph rendering engine
‚îÇ   ‚îú‚îÄ‚îÄ foundry/                # Procedural Glyph Foundry
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ grammar.py         # Tile grammar & edge codes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ palettes.py        # Color palette system
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edges.py           # WFC edge compatibility
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generator.py       # AI tile generation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validator.py       # Tile validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler.py        # Glyph auto-generation
‚îÇ   ‚îú‚îÄ‚îÄ tests/                  # Test suite (260+ tests)
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt        # Python dependencies
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ glyphs.json            # 80+ glyph definitions
‚îÇ   ‚îú‚îÄ‚îÄ animations.json        # Animation sequences
‚îÇ   ‚îú‚îÄ‚îÄ tiles.json             # Legacy tile definitions
‚îÇ   ‚îú‚îÄ‚îÄ biomes.json            # 8 biome configurations
‚îÇ   ‚îú‚îÄ‚îÄ enemies.json           # Enemy definitions
‚îÇ   ‚îú‚îÄ‚îÄ items.json             # Item definitions
‚îÇ   ‚îî‚îÄ‚îÄ palettes.json          # Color palettes
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx            # Main React component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/        # UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # API & WebSocket services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/             # React hooks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fonts/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ DungeonTiles.ttf  # Custom tileset font
‚îÇ   ‚îú‚îÄ‚îÄ package.json           # Node dependencies
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts         # Vite build configuration
‚îî‚îÄ‚îÄ README.md                   # This file
üöÄ Installation
Prerequisites

Python 3.8+
Node.js 16+
OpenAI API Key (or compatible LLM API)

Backend Setup

Clone the repository:

bashgit clone https://github.com/yourusername/tile-crawler.git
cd tile-crawler/backend

Install Python dependencies:

bashpip install -r requirements.txt

Create environment file:

bashecho "OPENAI_API_KEY=sk-your-key-here" > .env

Start the backend server:

bashuvicorn main:app --reload
The API will be available at http://127.0.0.1:8000
Frontend Setup

Navigate to frontend directory:

bashcd ../frontend

Install Node dependencies:

bashnpm install

Add your custom font (optional):

Place your .ttf tileset font in src/fonts/
Update index.css with the font name
Or use the default monospace fallback


Start the development server:

bashnpm run dev
```

Visit `http://localhost:5173` to play!

## üéÆ How to Play

### Basic Controls

**Movement:**
- **NORTH** - Move up
- **SOUTH** - Move down
- **EAST** - Move right
- **WEST** - Move left

**Actions:**
- **TALK** - Speak with NPCs in your current location
- **TAKE** - Pick up items you find
- **USE** - Utilize items from your inventory

### Gameplay Loop

1. **Start** in a procedurally generated dungeon
2. **Explore** by moving through rooms
3. **Discover** NPCs, items, and narrative events
4. **Interact** with the world through commands
5. **Experience** a coherent story maintained by the AI

### Example Session
```
> NORTH
You step into a corridor of cold stone. Torches flicker weakly on 
the walls, casting dancing shadows across ancient carvings.

> TAKE torch
You pick up an old torch. The flame sputters but holds steady.
Inventory: ["torch"]

> EAST
A narrow bridge crosses a dark chasm. The wind howls from below.

> TALK
A hooded figure emerges from the shadows.
"The deeper passages hold secrets," they whisper, "but few return."

> USE torch
You raise the torch high. Its light reveals glyphs on the bridge 
supports - a warning in an old tongue.
üß† Technical Deep Dive
LLM Integration
The game uses OpenAI's API (default: gpt-4o-mini) to generate dynamic content. Each turn, the LLM receives:
Input Context:

Current world state (map, player position)
Narrative memory (last 10 story events)
Player inventory
Player command

Output:
json{
  "map": ["‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì", "‚ñì@‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñì", ...],
  "description": "Immersive narrative text...",
  "player": [x, y],
  "inventory_change": "add: rusty key"
}
Memory Systems
World Memory (world_state.py)

Stores each explored room by coordinate key (x,y)
Prevents re-generation of previously visited areas
Creates a persistent, explorable world

Narrative Memory (narrative_memory.py)

Maintains a rolling log of recent events (last 10)
Passed to LLM for contextual awareness
Ensures story continuity and consistent tone

Inventory System (inventory_state.py)

Tracks items player has collected
Persists across sessions
Can be referenced by LLM for contextual actions

Custom Font Rendering
The frontend uses CSS @font-face to load a custom tileset:
css@font-face {
  font-family: 'DungeonTiles';
  src: url('./fonts/DungeonTiles.ttf') format('truetype');
}
The map is rendered as a <pre> element with the custom font applied:
tsx<pre className="text-4xl leading-none whitespace-pre tracking-tighter font-tileset">
  {mapData.join("\n")}
</pre>
```

Each character in the text grid is automatically rendered as the corresponding tile glyph.

## üé® Creating Custom Tilesets

### Font Requirements

- **Monospaced**: All glyphs must be same width for grid alignment
- **Format**: TrueType (.ttf) or OpenType (.otf)
- **Character Mapping**: Assign tile graphics to specific characters

### Recommended Tools

- **FontForge** (free, open-source)
- **Glyphs** (Mac, professional)
- **Birdfont** (cross-platform)

### Design Tips

1. **Keep it simple**: 16x16 or 32x32 pixel tiles work best
2. **High contrast**: Ensure tiles are distinguishable at small sizes
3. **Consistent style**: Maintain visual coherence across all tiles
4. **Test alignment**: Verify grid spacing in your font editor

### Example Character Map
```
Basic Tiles:
‚ñì ‚ñë @ $ ‚ò∫ ‚âà ‚ñ≤ ‚ô£ ‚ô† ‚óä ‚ñ† ‚ñ° ‚ñ™ ‚ñ´ ‚óè ‚óã

Extended Set:
‚ïî ‚ïê ‚ïó ‚ïë ‚ïö ‚ïù ‚ï† ‚ï£ ‚ï¨ ‚îå ‚îÄ ‚îê ‚îÇ ‚îî ‚îò ‚îú ‚î§ ‚îº
üè≠ Procedural Glyph Foundry

The Foundry is an AI-powered tile generation pipeline that creates parametrically constrained micro-tiles. AI doesn't create "art" - it creates tiles that obey rules.

### Tile Grammar

Each tile is defined by a structured grammar, not prose:

```python
TileGrammar(
    category="wall",
    subcategory="corner",
    palette="stone_gray",
    edges=EdgeSignature(N=SOLID, E=SOLID, S=EMPTY, W=EMPTY),
    center="stone",
    styles=[TileStyle.PIXEL, TileStyle.HIGH_CONTRAST],
    damage_state=0,    # 0-3: pristine to broken
    lighting_state=1,  # 0-2: dark to bright
    moisture_state=0,  # 0-1: dry to wet
)
```

### Edge Compatibility (WFC-Ready)

Every tile declares edge signatures for perfect meshing:

| Edge Code | Meaning       |
|-----------|---------------|
| 0         | Empty/open    |
| 1         | Solid wall    |
| 2         | Floor level   |
| 3         | Water edge    |
| 5         | Door frame    |

A corner wall: `edges: {N: 1, E: 1, S: 0, W: 0}`

### Combinatorial Generation

Batch generation via parameter combinations:

```
20 terrain bases
√ó 8 edge variants
√ó 4 damage states
√ó 3 lighting states
√ó 2 moisture states
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
= 3,840 tiles
```

### Palettes

12 built-in palettes with 4-color constraints:
- `stone_gray` - Dungeon/cave walls
- `wood_brown` - Doors, furniture
- `nature_green` - Forest biome
- `water_blue` - Rivers, lakes
- `lava_orange` - Volcano hazards
- `void_purple` - Magical effects

### Validation Pipeline

Each generated tile is validated for:
- ‚úì Correct pixel dimensions
- ‚úì Only allowed palette colors
- ‚úì Edge pixels match declared codes
- ‚úì No anti-aliasing artifacts
- ‚úì Consistent center texture

Failures are automatically regenerated.

üîß Configuration
LLM Settings
Edit backend/llm_engine.py:
pythonresponse = await openai.ChatCompletion.acreate(
    model="gpt-4o-mini",  # Change model here
    messages=[{"role": "user", "content": prompt}],
    temperature=0.8,  # Adjust creativity (0.0-1.0)
)
Temperature Guide:

0.3-0.5: More consistent, predictable
0.6-0.8: Balanced creativity (recommended)
0.9-1.0: Highly creative, unpredictable

Memory Limits
Adjust context window size in narrative_memory.py:
pythonif len(memory["log"]) > 10:  # Change limit here
    memory["log"] = memory["log"][-10:]
Tile Appearance
Modify frontend styling in App.tsx:
tsx<pre className="text-4xl">  {/* Change size */}
üõ£Ô∏è Roadmap

### Completed Features ‚úÖ

- [x] **Combat System**: Turn-based battles with LLM-narrated encounters
- [x] **Multiple Biomes**: 8 biomes (Dungeon, Cave, Crypt, Ruins, Temple, Forest, Volcano, Void)
- [x] **Save/Load**: Database persistence with SQLite/PostgreSQL
- [x] **User Authentication**: JWT-based login with per-user saves
- [x] **WebSocket Support**: Real-time game updates
- [x] **Sound Effects**: TTS-based procedural audio synthesis
- [x] **GASR Glyph System**: 80+ semantic glyph definitions
- [x] **Procedural Glyph Foundry**: AI tile generation pipeline
- [x] **Multi-Layer Rendering**: 6-layer SNES-style compositing
- [x] **API Documentation**: OpenAPI/Swagger docs
- [x] **E2E Testing**: Playwright test suite
- [x] **CI/CD Pipeline**: Automated testing and deployment

### Planned Features

- [ ] Quest System: Dynamic objectives generated by AI
- [ ] Multiplayer: Shared world exploration
- [ ] Color Tilesets: COLR/CPAL font support for rich graphics
- [ ] Mobile Controls: Touch-friendly interface
- [ ] Fog of War: Hide unexplored areas
- [ ] Character Classes: Different starting abilities
- [ ] Magic System: Spells with visual effects
- [ ] Crafting: Combine items for new tools
- [ ] Achievement System: Track player milestones

### Experimental Ideas

- Multi-Agent NPCs: Different AI personalities for different characters
- Procedural Quests: LLM-generated mission chains
- Dynamic Difficulty: AI adjusts challenge based on player skill
- Voice Narration: Text-to-speech for descriptions
- AR/VR Mode: Immersive tile-world exploration
- Modder Tile Generation: Custom tilesets via AI prompts

ü§ù Contributing
Contributions are welcome! This project is particularly suited for:

Game Designers: New mechanics, balance, content
AI Engineers: Prompt optimization, memory systems
Artists: Custom tilesets, UI improvements
Frontend Devs: React components, animations
Backend Devs: API optimization, new endpoints

Development Workflow

Fork the repository
Create a feature branch (git checkout -b feature/amazing-feature)
Commit your changes (git commit -m 'Add amazing feature')
Push to the branch (git push origin feature/amazing-feature)
Open a Pull Request

üìù License
This project is licensed under the MIT License - see the LICENSE file for details.
üôè Acknowledgments

Roguelike Tradition: Inspired by NetHack, Dwarf Fortress, and ADOM
Interactive Fiction: Zork and Infocom games
AI Dungeon: Pioneering LLM-based storytelling
ASCII Art: The timeless beauty of text graphics

üìû Contact

GitHub: @yourusername
Email: your.email@example.com
Discord: Tile-Crawler Community

üåü Why This Matters
Tile-Crawler represents a convergence of three powerful traditions:

Roguelike Gameplay: Procedural generation, permadeath, exploration
Interactive Fiction: Narrative depth, player agency
AI-Powered Worlds: Dynamic content that responds to player choices

By using LLMs as procedural content generators and dungeon masters, we can create infinitely replayable experiences that feel handcrafted and narratively coherent. The custom font tileset approach bridges the gap between text-based and graphical games, offering the best of both worlds: the flexibility of text with the visual appeal of graphics.
This is more than a game‚Äîit's a new medium for interactive storytelling.

Ready to explore the depths? Start the backend, fire up the frontend, and let the AI dungeon master guide you into the unknown.
bash# Terminal 1
cd backend && uvicorn main:app --reload

# Terminal 2
cd frontend && npm run dev
May your torch never fade, adventurer. üî•
