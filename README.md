Tile-Crawler
An LLM-Powered Text-Based Dungeon Crawler with Custom Font Tilesets
Tile-Crawler is a next-generation roguelike that merges procedural world generation, LLM storytelling, and ASCII/roguelike visual aesthetics. It uses large language models as dynamic dungeon masters that output text-based tile grids, rendered in-browser using custom font tilesets.
üéÆ Overview
Tile-Crawler represents a new approach to procedural game design: instead of hardcoded rules and static content, the game world is generated and narrated by an AI that maintains narrative continuity, remembers your actions, and creates coherent, evolving dungeons as you explore.
Core Concept:
LLM (Game Master)
       ‚Üì
Generates tilemap as text/JSON
       ‚Üì
React Frontend renders using custom font tileset
       ‚Üì
Player input ‚Üí sent back to LLM for next state
The LLM acts as both world generator and storyteller, while the frontend displays tiles using a custom font where each character represents a visual element (walls, floors, player, NPCs, items).
‚ú® Features
Core Gameplay

Dynamic World Generation: Every room, corridor, and encounter is generated by the LLM in real-time
Persistent World Memory: Previously explored areas are saved and remain consistent
Narrative Continuity: The LLM maintains a story log, ensuring tone and context across your adventure
Character Dialogue: Encounter NPCs with dynamic personalities and contextual conversations
Inventory System: Pick up, use, and manage items throughout your journey
Custom Font Tilesets: Render the world using beautiful monospaced tile fonts

Technical Features

Stateful LLM Integration: Context-aware AI that remembers previous rooms, actions, and story beats
Modular Architecture: Clean separation between world state, narrative memory, and inventory
RESTful API: FastAPI backend for clean client-server communication
Real-time Rendering: React-based frontend with Tailwind styling
Extensible Design: Easy to add new tile types, NPC behaviors, or game mechanics

üèóÔ∏è Architecture
System Flow
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Player Input                      ‚îÇ
‚îÇ            (north, south, east, west,                ‚îÇ
‚îÇ             talk, take, use, etc.)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              FastAPI Backend                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ           LLM Engine (OpenAI)               ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Generates next state                     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Maintains narrative voice                ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Handles NPC dialogue                     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Manages item interactions                ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                   ‚Üì          ‚Üì          ‚Üì            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   World      ‚îÇ ‚îÇ  Narrative   ‚îÇ ‚îÇ Inventory‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   Memory     ‚îÇ ‚îÇ   Memory     ‚îÇ ‚îÇ  State   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ (rooms/map)  ‚îÇ ‚îÇ (story log)  ‚îÇ ‚îÇ (items)  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               React Frontend                         ‚îÇ
‚îÇ  ‚Ä¢ Renders tilemap using custom font                ‚îÇ
‚îÇ  ‚Ä¢ Displays narrative descriptions                   ‚îÇ
‚îÇ  ‚Ä¢ Shows inventory                                   ‚îÇ
‚îÇ  ‚Ä¢ Provides movement/action controls                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Tile System
The game uses simple text characters mapped to visual tiles through a custom font:
Character ‚Üí Visual Tile
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚ñì      ‚Üí   Wall
  ‚ñë      ‚Üí   Floor
  @      ‚Üí   Player
  $      ‚Üí   Item
  ‚ò∫      ‚Üí   NPC
  ‚âà      ‚Üí   Water
  ‚ñ≤      ‚Üí   Mountain
  ‚ô£      ‚Üí   Tree
üìÅ Project Structure
tile-crawler/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                  # FastAPI application entry point
‚îÇ   ‚îú‚îÄ‚îÄ llm_engine.py           # OpenAI integration & prompt management
‚îÇ   ‚îú‚îÄ‚îÄ world_state.py          # Persistent world/room storage
‚îÇ   ‚îú‚îÄ‚îÄ narrative_memory.py     # Story continuity system
‚îÇ   ‚îú‚îÄ‚îÄ inventory_state.py      # Player inventory management
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt        # Python dependencies
‚îÇ   ‚îú‚îÄ‚îÄ .env                    # API keys (not committed)
‚îÇ   ‚îú‚îÄ‚îÄ world_state.json        # Generated world data
‚îÇ   ‚îú‚îÄ‚îÄ narrative_memory.json   # Story log
‚îÇ   ‚îî‚îÄ‚îÄ inventory_state.json    # Current inventory
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx            # Main React component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.css          # Tailwind & custom font styles
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fonts/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ DungeonTiles.ttf  # Custom tileset font
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js     # Tailwind configuration
‚îÇ   ‚îú‚îÄ‚îÄ package.json           # Node dependencies
‚îÇ   ‚îú‚îÄ‚îÄ vite.config.ts         # Vite build configuration
‚îÇ   ‚îî‚îÄ‚îÄ index.html             # Entry HTML
‚îî‚îÄ‚îÄ README.md                   # This file
üöÄ Installation
Prerequisites

Python 3.8+
Node.js 16+
OpenAI API Key (or compatible LLM API)

Backend Setup

Clone the repository:

bashgit clone https://github.com/yourusername/tile-crawler.git
cd tile-crawler/backend

Install Python dependencies:

bashpip install -r requirements.txt

Create environment file:

bashecho "OPENAI_API_KEY=sk-your-key-here" > .env

Start the backend server:

bashuvicorn main:app --reload
The API will be available at http://127.0.0.1:8000
Frontend Setup

Navigate to frontend directory:

bashcd ../frontend

Install Node dependencies:

bashnpm install

Add your custom font (optional):

Place your .ttf tileset font in src/fonts/
Update index.css with the font name
Or use the default monospace fallback


Start the development server:

bashnpm run dev
```

Visit `http://localhost:5173` to play!

## üéÆ How to Play

### Basic Controls

**Movement:**
- **NORTH** - Move up
- **SOUTH** - Move down
- **EAST** - Move right
- **WEST** - Move left

**Actions:**
- **TALK** - Speak with NPCs in your current location
- **TAKE** - Pick up items you find
- **USE** - Utilize items from your inventory

### Gameplay Loop

1. **Start** in a procedurally generated dungeon
2. **Explore** by moving through rooms
3. **Discover** NPCs, items, and narrative events
4. **Interact** with the world through commands
5. **Experience** a coherent story maintained by the AI

### Example Session
```
> NORTH
You step into a corridor of cold stone. Torches flicker weakly on 
the walls, casting dancing shadows across ancient carvings.

> TAKE torch
You pick up an old torch. The flame sputters but holds steady.
Inventory: ["torch"]

> EAST
A narrow bridge crosses a dark chasm. The wind howls from below.

> TALK
A hooded figure emerges from the shadows.
"The deeper passages hold secrets," they whisper, "but few return."

> USE torch
You raise the torch high. Its light reveals glyphs on the bridge 
supports - a warning in an old tongue.
üß† Technical Deep Dive
LLM Integration
The game uses OpenAI's API (default: gpt-4o-mini) to generate dynamic content. Each turn, the LLM receives:
Input Context:

Current world state (map, player position)
Narrative memory (last 10 story events)
Player inventory
Player command

Output:
json{
  "map": ["‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì", "‚ñì@‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñì", ...],
  "description": "Immersive narrative text...",
  "player": [x, y],
  "inventory_change": "add: rusty key"
}
Memory Systems
World Memory (world_state.py)

Stores each explored room by coordinate key (x,y)
Prevents re-generation of previously visited areas
Creates a persistent, explorable world

Narrative Memory (narrative_memory.py)

Maintains a rolling log of recent events (last 10)
Passed to LLM for contextual awareness
Ensures story continuity and consistent tone

Inventory System (inventory_state.py)

Tracks items player has collected
Persists across sessions
Can be referenced by LLM for contextual actions

Custom Font Rendering
The frontend uses CSS @font-face to load a custom tileset:
css@font-face {
  font-family: 'DungeonTiles';
  src: url('./fonts/DungeonTiles.ttf') format('truetype');
}
The map is rendered as a <pre> element with the custom font applied:
tsx<pre className="text-4xl leading-none whitespace-pre tracking-tighter font-tileset">
  {mapData.join("\n")}
</pre>
```

Each character in the text grid is automatically rendered as the corresponding tile glyph.

## üé® Creating Custom Tilesets

### Font Requirements

- **Monospaced**: All glyphs must be same width for grid alignment
- **Format**: TrueType (.ttf) or OpenType (.otf)
- **Character Mapping**: Assign tile graphics to specific characters

### Recommended Tools

- **FontForge** (free, open-source)
- **Glyphs** (Mac, professional)
- **Birdfont** (cross-platform)

### Design Tips

1. **Keep it simple**: 16x16 or 32x32 pixel tiles work best
2. **High contrast**: Ensure tiles are distinguishable at small sizes
3. **Consistent style**: Maintain visual coherence across all tiles
4. **Test alignment**: Verify grid spacing in your font editor

### Example Character Map
```
Basic Tiles:
‚ñì ‚ñë @ $ ‚ò∫ ‚âà ‚ñ≤ ‚ô£ ‚ô† ‚óä ‚ñ† ‚ñ° ‚ñ™ ‚ñ´ ‚óè ‚óã

Extended Set:
‚ïî ‚ïê ‚ïó ‚ïë ‚ïö ‚ïù ‚ï† ‚ï£ ‚ï¨ ‚îå ‚îÄ ‚îê ‚îÇ ‚îî ‚îò ‚îú ‚î§ ‚îº
üîß Configuration
LLM Settings
Edit backend/llm_engine.py:
pythonresponse = await openai.ChatCompletion.acreate(
    model="gpt-4o-mini",  # Change model here
    messages=[{"role": "user", "content": prompt}],
    temperature=0.8,  # Adjust creativity (0.0-1.0)
)
Temperature Guide:

0.3-0.5: More consistent, predictable
0.6-0.8: Balanced creativity (recommended)
0.9-1.0: Highly creative, unpredictable

Memory Limits
Adjust context window size in narrative_memory.py:
pythonif len(memory["log"]) > 10:  # Change limit here
    memory["log"] = memory["log"][-10:]
Tile Appearance
Modify frontend styling in App.tsx:
tsx<pre className="text-4xl">  {/* Change size */}
üõ£Ô∏è Roadmap
Planned Features

 Combat System: Turn-based battles with LLM-narrated encounters
 Quest System: Dynamic objectives generated by AI
 Multiple Biomes: Dungeons, forests, cities, ruins
 Save/Load: Persistent game sessions
 Multiplayer: Shared world exploration
 Color Tilesets: COLR/CPAL font support for rich graphics
 Sound Effects: Audio feedback for actions
 Mobile Controls: Touch-friendly interface
 Fog of War: Hide unexplored areas
 Character Classes: Different starting abilities
 Magic System: Spells with visual effects
 Crafting: Combine items for new tools
 Achievement System: Track player milestones

Experimental Ideas

Multi-Agent NPCs: Different AI personalities for different characters
Procedural Quests: LLM-generated mission chains
Dynamic Difficulty: AI adjusts challenge based on player skill
Voice Narration: Text-to-speech for descriptions
AR/VR Mode: Immersive tile-world exploration

ü§ù Contributing
Contributions are welcome! This project is particularly suited for:

Game Designers: New mechanics, balance, content
AI Engineers: Prompt optimization, memory systems
Artists: Custom tilesets, UI improvements
Frontend Devs: React components, animations
Backend Devs: API optimization, new endpoints

Development Workflow

Fork the repository
Create a feature branch (git checkout -b feature/amazing-feature)
Commit your changes (git commit -m 'Add amazing feature')
Push to the branch (git push origin feature/amazing-feature)
Open a Pull Request

üìù License
This project is licensed under the MIT License - see the LICENSE file for details.
üôè Acknowledgments

Roguelike Tradition: Inspired by NetHack, Dwarf Fortress, and ADOM
Interactive Fiction: Zork and Infocom games
AI Dungeon: Pioneering LLM-based storytelling
ASCII Art: The timeless beauty of text graphics

üìû Contact

GitHub: @yourusername
Email: your.email@example.com
Discord: Tile-Crawler Community

üåü Why This Matters
Tile-Crawler represents a convergence of three powerful traditions:

Roguelike Gameplay: Procedural generation, permadeath, exploration
Interactive Fiction: Narrative depth, player agency
AI-Powered Worlds: Dynamic content that responds to player choices

By using LLMs as procedural content generators and dungeon masters, we can create infinitely replayable experiences that feel handcrafted and narratively coherent. The custom font tileset approach bridges the gap between text-based and graphical games, offering the best of both worlds: the flexibility of text with the visual appeal of graphics.
This is more than a game‚Äîit's a new medium for interactive storytelling.

Ready to explore the depths? Start the backend, fire up the frontend, and let the AI dungeon master guide you into the unknown.
bash# Terminal 1
cd backend && uvicorn main:app --reload

# Terminal 2
cd frontend && npm run dev
May your torch never fade, adventurer. üî•
